{"version":3,"file":"gondel.es5.min.js","sources":["GondelPluginUtils.js","GondelEventEmitter.js","GondelComponentStarter.js","GondelComponentRegistry.js","GondelDomUtils.js","GondelEventRegistry.js","GondelDecorators.js","GondelComponent.js"],"sourcesContent":["var basePluginListener = function (result, data, next) { return next(result); };\n// Global plugin events registry\nexport var pluginEvents = window.__gondelPluginEvents || {};\nwindow.__gondelPluginEvents = pluginEvents;\nexport function fireGondelPluginEvent(eventName, initialValue, data, callback) {\n    var isSyncron = false;\n    var callbackResult;\n    // Execute all bound events for the given name\n    // if they exist\n    (pluginEvents[eventName] || basePluginListener)(initialValue, data, function (processedResult) {\n        isSyncron = true;\n        callbackResult = callback ? callback(processedResult) : processedResult;\n    });\n    // Add a guard to prevent asyncron plugin listeners\n    // to simplify the usage of fireGondelPluginEvent\n    if (!isSyncron) {\n        throw new Error(\"Async plugin listener\");\n    }\n    return callbackResult;\n}\n/**\n * Fire an async event which allows gondel plugins to add features to gondel\n */\nexport function fireAsyncGondelPluginEvent(eventName, initialValue, data) {\n    return new Promise(function (resolve) {\n        (pluginEvents[eventName] || basePluginListener)(initialValue, data, function (result) {\n            resolve(result);\n        });\n    });\n}\n/**\n * Allow plugins to hook into the gondel event system\n */\nexport function addGondelPluginEventListener(eventName, eventListenerCallback) {\n    if (!pluginEvents[eventName]) {\n        pluginEvents[eventName] = basePluginListener;\n    }\n    var previousEventHandler = pluginEvents[eventName];\n    pluginEvents[eventName] = function wrapCallback(result, data, next) {\n        previousEventHandler(result, data, function callNextPlugin(modifiedResult, _, firstNext) {\n            eventListenerCallback(modifiedResult, data, function bindData(result) {\n                next(result, data, firstNext);\n            });\n        });\n    };\n}\n//# sourceMappingURL=GondelPluginUtils.js.map","import { getFirstDomNode } from \"./GondelDomUtils\";\n/**\n * Submit an event which might be caught by foreign gondel, angular or react components\n */\nexport function triggerPublicEvent(eventName, gondelComponent, target, eventData, canBubble) {\n    if (eventData === void 0) { eventData = {}; }\n    if (canBubble === void 0) { canBubble = true; }\n    var event = document.createEvent(\"Event\");\n    var eventTarget = target ? getFirstDomNode(target) : gondelComponent._ctx;\n    if (eventName[0] !== gondelComponent._namespace) {\n        throw new Error(\"Invalid event name '\" +\n            eventName +\n            \"' - use '\" +\n            gondelComponent._namespace +\n            eventName.charAt(0).toUpperCase() +\n            eventName.slice(1) +\n            \"'\");\n    }\n    event.initEvent(eventName, canBubble, true);\n    event.data = {\n        component: gondelComponent,\n        name: gondelComponent._componentName,\n        namespace: gondelComponent._namespace,\n        eventData: eventData\n    };\n    return eventTarget.dispatchEvent(event);\n}\n//# sourceMappingURL=GondelEventEmitter.js.map","import { fireGondelPluginEvent } from \"./GondelPluginUtils\";\nimport { triggerPublicEvent } from \"./GondelEventEmitter\";\nimport { getGondelAttribute } from \"./GondelDomUtils\";\nvar noop = function () { };\nvar Deferred = function () {\n    var _this = this;\n    this.promise = new Promise(function (resolve) {\n        _this.resolve = resolve;\n    });\n};\n/**\n * Start all components of the gondel component registry\n * for the given dom context\n */\nexport function startComponentsFromRegistry(gondelComponentRegistry, domContext, namespace) {\n    // Get an array of all nodes which match the namespace\n    var gondelDomNodeList = Array.prototype.slice.call(domContext.querySelectorAll(\"[data-\" + namespace + \"-name]\"));\n    if (domContext.hasAttribute(\"data-\" + namespace + \"-name\")) {\n        gondelDomNodeList.push(domContext);\n    }\n    // Remove already booted nodes\n    var pristineGondelDomNodes = gondelDomNodeList.filter(function (gondelDomNode) {\n        return isPristineGondelDomNode(gondelDomNode, namespace);\n    });\n    var bootingDeferred = new Deferred();\n    // Mark all nodes as booting\n    pristineGondelDomNodes.forEach(function (gondelDomNode) {\n        attachGondelBootingFlag(gondelDomNode, bootingDeferred.promise, namespace);\n    });\n    // Create instances\n    var gondelComponents = fireGondelPluginEvent(\"boot\", pristineGondelDomNodes, { namespace: namespace }, function (pristineGondelDomNodes) {\n        return pristineGondelDomNodes.map(function (gondelDomNode) {\n            return constructComponent(gondelDomNode, gondelComponentRegistry, namespace);\n        });\n    });\n    // Get all component names\n    var newComponentNames = getNewComponents(gondelComponents, gondelComponentRegistry);\n    newComponentNames.forEach(function (componentName) {\n        return gondelComponentRegistry.setActiveState(componentName, true);\n    });\n    // Start all components\n    var gondelComponentStartPromise = fireGondelPluginEvent(\"start\", gondelComponents, { newComponentNames: newComponentNames, namespace: namespace, gondelComponentRegistry: gondelComponentRegistry }, function (gondelComponents) {\n        // Wait for async started components\n        return Promise.all(gondelComponents.map(startConstructedComponent));\n    })\n        // Let all plugins know that the components are now all ready to use\n        .then(function () {\n        gondelComponents.forEach(function (gondelComponent) {\n            if (gondelComponent.sync) {\n                gondelComponent.sync();\n            }\n        });\n        return fireGondelPluginEvent(\"sync\", gondelComponents, { namespace: namespace });\n    });\n    // Resolve the booting deferred\n    gondelComponentStartPromise.then(bootingDeferred.resolve, bootingDeferred.resolve);\n    // Return a promise of all started components\n    return gondelComponentStartPromise;\n}\n/**\n * Returns true if the given domNode is neither booting nor booted\n */\nexport function isPristineGondelDomNode(domNode, namespace) {\n    return !domNode.hasOwnProperty(getGondelAttribute(namespace, \"async\"));\n}\n/**\n * Mark the given dom node as controlled by gondel\n */\nexport function attachGondelBootingFlag(domNode, bootingFlag, namespace) {\n    // The name `A` mean async\n    // to allow waiting for asyncronous booted components\n    domNode[getGondelAttribute(namespace, \"async\")] = bootingFlag;\n}\n/**\n * Constructs a new component\n */\nexport function constructComponent(domNode, gondelComponentRegisty, namespace) {\n    var componentName = domNode.getAttribute(\"data-\" + namespace + \"-name\");\n    var GondelComponent = gondelComponentRegisty.getComponent(componentName);\n    if (GondelComponent === undefined) {\n        throw new Error(\"Failed to boot component - \" + componentName + \" is not registred\");\n    }\n    var componentInstance = new GondelComponent(domNode, componentName);\n    componentInstance._ctx = domNode;\n    componentInstance._namespace = namespace;\n    // Adopt component name from blueprint\n    componentInstance._componentName = GondelComponent.__identification[namespace];\n    // Add stop method\n    componentInstance.stop = stopStartedComponent.bind(null, componentInstance, componentInstance.stop || noop, namespace);\n    // Create a circular reference which will allow access to the componentInstance from ctx\n    domNode[getGondelAttribute(namespace)] = componentInstance;\n    return componentInstance;\n}\n/**\n * Start a component after it was constructed\n */\nexport function startConstructedComponent(component) {\n    // Skip if the start method is missing\n    if (!component.start) {\n        return;\n    }\n    var expectsNoArguments = component.start.length === 0;\n    // Start the component and expect a promise or a syncronous return value\n    // if the function expects no arguments\n    if (expectsNoArguments) {\n        return component.start();\n    }\n    return new Promise(function (resolve, reject) { return component.start(resolve, reject); });\n}\n/**\n * Stops a started component\n */\nexport function stopStartedComponent(component, internalStopMethod, namespace) {\n    triggerPublicEvent(namespace + \"Stop\", component, component._ctx);\n    // Remove the component instance from the html element\n    delete component._ctx[getGondelAttribute(namespace)];\n    delete component._ctx[getGondelAttribute(namespace, \"async\")];\n    component._stopped = true;\n    fireGondelPluginEvent(\"stop\", component, { namespace: namespace }, internalStopMethod.bind(component));\n}\n/**\n * Filters the given component list and returns the names of those components which have never been started before\n */\nfunction getNewComponents(components, registry) {\n    var componentNameHelper = {};\n    components.forEach(function (component) { return (componentNameHelper[component._componentName] = true); });\n    var componentNames = Object.keys(componentNameHelper);\n    return componentNames.filter(function (componentName) { return !registry._activeComponents[componentName]; });\n}\n//# sourceMappingURL=GondelComponentStarter.js.map","import { fireGondelPluginEvent } from \"./GondelPluginUtils\";\nvar GondelComponentRegistry = /** @class */ (function () {\n    function GondelComponentRegistry() {\n        this._components = {};\n        this._activeComponents = {};\n    }\n    GondelComponentRegistry.prototype.registerComponent = function (name, gondelComponent) {\n        this._components[name] = gondelComponent;\n    };\n    GondelComponentRegistry.prototype.unregisterComponent = function (name) {\n        delete this._components[name];\n    };\n    GondelComponentRegistry.prototype.getComponent = function (name) {\n        return this._components[name];\n    };\n    /**\n     * Set if a component is used\n     */\n    GondelComponentRegistry.prototype.setActiveState = function (name, isActive) {\n        this._activeComponents[name] = isActive;\n    };\n    return GondelComponentRegistry;\n}());\nexport { GondelComponentRegistry };\nexport var componentRegistries = (window.__gondelRegistries = window.__gondelRegistries || {});\nexport function registerComponent(componentName, component, namespace) {\n    if (namespace === void 0) { namespace = \"g\"; }\n    // Add an identifier to the constructor\n    // for mapping the class to a dom query selector\n    var identifiedComponent = component;\n    if (!identifiedComponent.hasOwnProperty('__identification')) {\n        identifiedComponent.__identification = {};\n    }\n    identifiedComponent.__identification[namespace] = componentName;\n    if (!componentRegistries[namespace]) {\n        componentRegistries[namespace] = new GondelComponentRegistry();\n    }\n    // If this component was already registered we remove the previous one\n    // and notify all plugins - this is especially usefull for hot component replacement\n    if (componentRegistries[namespace].getComponent(componentName)) {\n        fireGondelPluginEvent(\"unregister\", component, { componentName: componentName, namespace: namespace });\n    }\n    // Let plugins know about the new component\n    fireGondelPluginEvent(\"register\", component, {\n        componentName: componentName,\n        namespace: namespace,\n        gondelComponentRegistry: componentRegistries[namespace]\n    }, function (component) {\n        componentRegistries[namespace].registerComponent(componentName, identifiedComponent);\n    });\n}\n//# sourceMappingURL=GondelComponentRegistry.js.map","import { startComponentsFromRegistry } from \"./GondelComponentStarter\";\nimport { componentRegistries } from \"./GondelComponentRegistry\";\n/**\n * Returns true if the given object is a single Element\n */\nfunction isElement(domNode) {\n    return domNode.nodeType !== undefined;\n}\n/**\n * Inspired by the RXJS anchor approach by using symbols (if supported) or strings\n * for internal fixtures.\n *\n * @param {string=g} namespace\n * @param {string?} addition\n * @see https://github.com/ReactiveX/rxjs/blob/master/src/internal/symbol/rxSubscriber.ts\n */\nexport function getGondelAttribute(namespace, addition) {\n    if (namespace === void 0) { namespace = \"g\"; }\n    var id = \"__gondel_\" + (addition ? addition + \"_\" : \"\") + namespace + \"__\";\n    if (Symbol && typeof Symbol.for === \"function\") {\n        return Symbol.for(id);\n    }\n    return id;\n}\n/**\n * This function normalizes takes one of the following:\n *  + document query result\n *  + dom node array\n *  + jquery object\n *  + a single dom node\n * and turns it into a single dom node\n */\nexport function getFirstDomNode(domNode) {\n    if (isElement(domNode)) {\n        return domNode;\n    }\n    return domNode[0];\n}\n/**\n *\n * @param gondelComponent\n * @param namespace\n */\nfunction getComponentName(gondelComponent, namespace) {\n    if (!gondelComponent._identifier) {\n        throw new Error('1 Unregistered component has no identifier.');\n    }\n    var identification = gondelComponent.__identification;\n    if (!identification[namespace]) {\n        throw new Error('2 No component for namespace ' + namespace);\n    }\n    return identification[namespace];\n}\n/**\n * Start all nodes in the given context\n */\nexport function startComponents(domContext, namespace) {\n    if (namespace === void 0) { namespace = \"g\"; }\n    if (!componentRegistries[namespace]) {\n        return Promise.resolve([]);\n    }\n    var registry = componentRegistries[namespace];\n    return startComponentsFromRegistry(registry, domContext ? getFirstDomNode(domContext) : document.documentElement, namespace);\n}\n/**\n * Stop all nodes in the given context\n */\nexport function stopComponents(domContext, namespace) {\n    if (namespace === void 0) { namespace = \"g\"; }\n    var components = findComponents(domContext, undefined, namespace);\n    var rootComponent = domContext && getComponentByDomNode(domContext);\n    if (rootComponent) {\n        components.unshift(rootComponent);\n    }\n    components.forEach(function (component) { return component.stop(); });\n}\nexport function isComponentMounted(domNode, namespace) {\n    if (namespace === void 0) { namespace = \"g\"; }\n    var firstNode = getFirstDomNode(domNode);\n    var gondelComponent = firstNode[getGondelAttribute(namespace)];\n    return gondelComponent && gondelComponent._ctx;\n}\n/**\n * Returns the gondel instance for the given HtmlELement\n */\nexport function getComponentByDomNode(domNode, namespace) {\n    if (namespace === void 0) { namespace = \"g\"; }\n    var firstNode = getFirstDomNode(domNode);\n    var gondelComponent = firstNode[getGondelAttribute(namespace)];\n    // Stop if this dom node is not known to gondel\n    if (gondelComponent && gondelComponent._ctx) {\n        return gondelComponent;\n    }\n    throw new Error(\"Could not find any gondel component in namespace \" + namespace + \" on node \" + firstNode.nodeName + \". \" +\n        \"This usually happens when the DOM content was modified by a third-party tool.\" +\n        \"Use 'isComponentMounted' to check if the component is mounted.\");\n}\n/**\n * Returns the gondel instance for the given HtmlELement once it is booted\n */\nexport function getComponentByDomNodeAsync(domNode, namespace) {\n    if (namespace === void 0) { namespace = \"g\"; }\n    var firstNode = getFirstDomNode(domNode);\n    var gondelComponent = firstNode[getGondelAttribute(namespace, \"async\")];\n    // Stop if this dom node is not known to gondel\n    if (!gondelComponent) {\n        return Promise.reject(undefined);\n    }\n    // or the component is already booted up return it\n    if (gondelComponent._ctx) {\n        return Promise.resolve(gondelComponent);\n    }\n    // Wait the component to boot up and return it\n    return gondelComponent.then(function () { return firstNode[getGondelAttribute(namespace)]; });\n}\nexport function findComponents(domNode, component, namespace) {\n    if (domNode === void 0) { domNode = document.documentElement; }\n    if (namespace === void 0) { namespace = \"g\"; }\n    var firstNode = getFirstDomNode(domNode);\n    var components = [];\n    var attribute = getGondelAttribute(namespace);\n    var nodes = firstNode.querySelectorAll(\"[data-\" + namespace + \"-name\" + (component ? \"=\\\"\" + (typeof component === \"string\" ? component : getComponentName(component, namespace)) + \"\\\"\" : \"\") + \"]\");\n    for (var i = 0; i < nodes.length; i++) {\n        var node = nodes[i];\n        var gondelComponentInstance = node[attribute];\n        // Verify that the component is fully booted\n        if (gondelComponentInstance && gondelComponentInstance._ctx === node) {\n            components.push(gondelComponentInstance);\n        }\n    }\n    if (typeof component === 'string') {\n        return components;\n    }\n    return components;\n}\n//# sourceMappingURL=GondelDomUtils.js.map","/**\n * The event registry provides a way to bind events ahead of time\n * with a very small foot print during launch to improve the time to interaction\n */\nimport { getComponentByDomNode } from \"./GondelDomUtils\";\nimport { fireGondelPluginEvent } from \"./GondelPluginUtils\";\n/**\n * Only real browser events are supported.\n * Unfortunately focus and blur do not bubble so a special mapping is needed.\n */\nvar eventNameMapping = {\n    focus: \"focusin\",\n    blur: \"focusout\"\n};\nvar domEventRegistry = window.__gondelDomEvents || {};\nwindow.__gondelDomEvents = domEventRegistry;\n/* istanbul ignore next : Browser polyfill can't be tested */\nvar matches = Element.prototype.matches ||\n    Element.prototype.matchesSelector ||\n    Element.prototype.mozMatchesSelector ||\n    Element.prototype.msMatchesSelector ||\n    Element.prototype.oMatchesSelector ||\n    Element.prototype.webkitMatchesSelector;\nfunction getParentElements(startElement) {\n    var nodes = [];\n    for (var element = startElement; element; element = element.parentElement) {\n        nodes.push(element);\n    }\n    return nodes;\n}\n/**\n * Returns an array of all handlers which would apply for the current target\n */\nexport function getHandlers(attributeName, eventHandlerRegistry, target) {\n    var parents = getParentElements(target);\n    // Find all selectors which have been registred for this event type\n    // and which have a gondel component in one of the parrent nodes\n    var selectorsOfFoundComponents = [];\n    parents.forEach(function (parent, i) {\n        var componentName = parent.getAttribute(attributeName);\n        var handlers = componentName && eventHandlerRegistry[componentName];\n        if (handlers) {\n            // Store the index where the component was found to know in which part\n            // of the dom tree the selectors could be found\n            selectorsOfFoundComponents.push({ index: i, handlers: handlers });\n        }\n    });\n    // Iterate over all possible selectors to find out if the current event\n    // should fire any gondel handler\n    var handlerQueue = [];\n    selectorsOfFoundComponents.forEach(function (_a) {\n        var index = _a.index, handlers = _a.handlers;\n        var selectorNames = Object.keys(handlers);\n        selectorNames.forEach(function (selectorName) {\n            // If no selector is given the handler does always match\n            if (!selectorName) {\n                return handlerQueue.push({\n                    index: index,\n                    ctx: parents[index],\n                    handlerOptions: handlers[selectorName]\n                });\n            }\n            // Iterate backwards over the children of the component to find an element\n            // which matches the selector for the current handler\n            for (var i = index; --i >= 0;) {\n                if (matches.call(parents[i], selectorName)) {\n                    return handlerQueue.push({\n                        index: i,\n                        ctx: parents[index],\n                        handlerOptions: handlers[selectorName]\n                    });\n                }\n            }\n        });\n    });\n    // Break if we couldn't find any matching element\n    if (handlerQueue.length === 0) {\n        return [];\n    }\n    // Sort the queue so events which are further up the dom are fired first\n    handlerQueue.sort(function (handlerA, handlerB) {\n        return handlerA.index > handlerB.index ? 1 : handlerA.index === handlerB.index ? 0 : -1;\n    });\n    return handlerQueue;\n}\n/**\n * The handler which will catch every event at the documentElement\n */\nfunction handleEvent(namespace, attributeName, eventHandlerRegistry, event) {\n    var target = event.target;\n    var handlers = getHandlers(attributeName, eventHandlerRegistry, target);\n    executeHandlers(handlers, event, namespace);\n}\n/**\n * Returns the namespace registry for the given namespace..\n * This function must be used only by core or plugins\n */\nexport function getEventRegistry(namespace) {\n    if (!domEventRegistry[namespace]) {\n        domEventRegistry[namespace] = {};\n    }\n    return domEventRegistry[namespace];\n}\n/**\n * Notify components\n * This function must be used by core or only by plugins\n */\nexport function executeHandlers(handlers, event, namespace) {\n    var results = [];\n    for (var i = 0; i < handlers.length && !event.cancelBubble; i++) {\n        var handlerObject = handlers[i];\n        var handlerOptions = handlerObject.handlerOptions;\n        var gondelComponent = getComponentByDomNode(handlerObject.ctx, namespace);\n        // Skip if the component wasn't started or if it was stopped\n        if (gondelComponent) {\n            for (var j = 0; j < handlerOptions.length && !event.cancelBubble; j++) {\n                var handlerResult = gondelComponent[handlerOptions[j].handlerName].call(gondelComponent, event);\n                if (typeof handlerResult === \"function\") {\n                    results.push(handlerResult);\n                }\n            }\n        }\n    }\n    // Execute all callbacks to allow grouping write events\n    results.forEach(function (result) {\n        result();\n    });\n}\n/**\n * Add a event lister to the <html> element\n * The listener will always call handleEvent with the domEventRegistry for the given event\n */\nfunction startListeningForEvent(eventName, namespace) {\n    document.documentElement.addEventListener(eventNameMapping[eventName] || eventName, handleEvent.bind(null, namespace, \"data-\" + namespace + \"-name\", domEventRegistry[namespace][eventName]));\n}\n/**\n * Add an event to the Gondel EventRegistry\n */\nexport function addRootEventListener(namespace, domEventName, gondelComponentName, handlerName, handlerOption) {\n    // Create namespace if neededi\n    var namespacedDomEventRegistry = getEventRegistry(namespace);\n    // Notify all plugins to allow taking over the event handling for a specific event name\n    // This notification is only triggered if a event name e.g. 'click' is used for the first time\n    if (!namespacedDomEventRegistry[domEventName]) {\n        namespacedDomEventRegistry[domEventName] = {};\n        fireGondelPluginEvent(\"registerEvent\", true, {\n            eventName: domEventName,\n            namespace: namespace,\n            eventRegistry: namespacedDomEventRegistry[domEventName]\n        }, function (isNativeEvent) {\n            // If no plugin registered the event\n            // register a native browser event\n            if (isNativeEvent) {\n                startListeningForEvent(domEventName, namespace);\n            }\n        });\n    }\n    if (!namespacedDomEventRegistry[domEventName][gondelComponentName]) {\n        namespacedDomEventRegistry[domEventName][gondelComponentName] = {};\n    }\n    var handlerOptionObject = typeof handlerOption === \"object\" ? handlerOption : { selector: handlerOption };\n    var selectorKey = handlerOptionObject.selector || \"\";\n    if (!namespacedDomEventRegistry[domEventName][gondelComponentName][selectorKey]) {\n        namespacedDomEventRegistry[domEventName][gondelComponentName][selectorKey] = [];\n    }\n    namespacedDomEventRegistry[domEventName][gondelComponentName][selectorKey].push(Object.assign({ handlerName: handlerName, handlerOption: handlerOption }));\n}\n/**\n * Remove an event from the Gondel EventRegistry\n */\nexport function removeRootEventListener(namespace, domEventName, gondelComponentName, handlerName, selector) {\n    var selectorKey = selector || \"\";\n    var namespacedDomEventRegistry = getEventRegistry(namespace);\n    if (namespacedDomEventRegistry[domEventName] &&\n        namespacedDomEventRegistry[domEventName][gondelComponentName] &&\n        namespacedDomEventRegistry[domEventName][gondelComponentName][selectorKey]) {\n        namespacedDomEventRegistry[domEventName][gondelComponentName][selectorKey] = namespacedDomEventRegistry[domEventName][gondelComponentName][selectorKey].filter(function (handlerOption) {\n            return handlerOption.handlerName !== handlerName || handlerName === undefined;\n        });\n    }\n}\n/**\n * Remove all events for a given Component (e.g. a Button) from the Gondel EventRegistry\n */\nexport function removeRootEventListernerForComponent(namespace, gondelComponentName) {\n    var namespacedDomEventRegistry = getEventRegistry(namespace);\n    for (var eventName in namespacedDomEventRegistry) {\n        /* istanbul ignore else: for in savety check */\n        if (namespacedDomEventRegistry.hasOwnProperty(eventName)) {\n            delete namespacedDomEventRegistry[eventName][gondelComponentName];\n        }\n    }\n}\n//# sourceMappingURL=GondelEventRegistry.js.map","import { addRootEventListener, removeRootEventListernerForComponent } from \"./GondelEventRegistry\";\n// Because of how decorators work @EventListeners is executed before the class is registred\n// so we need to provide a hrm compatible approch initialize and reinitialize the events\nimport { addGondelPluginEventListener } from \"./GondelPluginUtils\";\nimport { registerComponent } from \"./index\";\n/**\n * Register a gondel component to the registry\n * @param {string} namespace   The gondel components namespace\n */\nexport function Component(componentName, namespace) {\n    if (namespace === void 0) { namespace = \"g\"; }\n    return function (constructor) {\n        registerComponent(componentName, constructor, namespace);\n    };\n}\nvar areEventsHookedIntoCore = false;\nfunction hookEventDecoratorInCore() {\n    areEventsHookedIntoCore = true;\n    addGondelPluginEventListener(\"register\", function (component, _a, next) {\n        var componentName = _a.componentName, namespace = _a.namespace, gondelComponentRegistry = _a.gondelComponentRegistry;\n        // Only apply in case the component is already active in the DOM\n        // this will only happen during hot module replacement\n        if (!gondelComponentRegistry._activeComponents[componentName]) {\n            return next(component);\n        }\n        // The decorator will store the event information in two different places.\n        // For ES6 classes it is using __events\n        // For ES5 prototype classes and transpiled ES6 classes it is using prototype.__events\n        var componentEventOptions = (component.prototype && component.prototype.__events) || component.__events;\n        if (componentEventOptions) {\n            componentEventOptions.forEach(function (eventOptions) {\n                addRootEventListener(namespace, \n                /* event name: */ eventOptions[0], componentName, \n                /* handler: */ eventOptions[1], \n                /* selector: */ eventOptions[2]);\n            });\n        }\n        next(component);\n    });\n    addGondelPluginEventListener(\"unregister\", function (component, _a, next) {\n        var componentName = _a.componentName, namespace = _a.namespace;\n        removeRootEventListernerForComponent(namespace, componentName);\n        next(component);\n    });\n    addGondelPluginEventListener(\"start\", function (gondelComponents, _a, next) {\n        var newComponentNames = _a.newComponentNames, gondelComponentRegistry = _a.gondelComponentRegistry, namespace = _a.namespace;\n        var components = newComponentNames.forEach(function (componentName) {\n            var gondelComponent = gondelComponentRegistry.getComponent(componentName);\n            // The decorator will store the event information in two different places.\n            // For ES6 classes it is using __events\n            // For ES5 prototype classes and transpiled ES6 classes it is using prototype.__events\n            var componentEventOptions = (gondelComponent.prototype && gondelComponent.prototype.__events) ||\n                gondelComponent.__events;\n            if (componentEventOptions) {\n                componentEventOptions.forEach(function (eventOptions) {\n                    addRootEventListener(namespace, \n                    /* event name: */ eventOptions[0], componentName, \n                    /* handler: */ eventOptions[1], \n                    /* selector: */ eventOptions[2]);\n                });\n            }\n        });\n        next(gondelComponents);\n    });\n}\n/**\n * The @EventListener decorator will add all event names to a static variable\n */\nexport function EventListener(eventName, selector) {\n    return function (target, handler) {\n        if (!areEventsHookedIntoCore) {\n            hookEventDecoratorInCore();\n        }\n        if (handler.substr(0, 1) !== \"_\") {\n            throw new Error(\"Invalid handler name '\" + handler + \"' use '_\" + handler + \"' instead.\");\n        }\n        if (!target.__events) {\n            target.__events = [];\n        }\n        target.__events.push([eventName, handler, selector]);\n    };\n}\n//# sourceMappingURL=GondelDecorators.js.map","var GondelBaseComponent = /** @class */ (function () {\n    function GondelBaseComponent() {\n    }\n    /**\n     * Stop method\n     */\n    GondelBaseComponent.prototype.stop = function () { };\n    /**\n     * The components initial identification mappings\n     */\n    GondelBaseComponent.__identification = {};\n    return GondelBaseComponent;\n}());\nexport { GondelBaseComponent };\n//# sourceMappingURL=GondelComponent.js.map"],"names":["basePluginListener","result","data","next","pluginEvents","window","__gondelPluginEvents","fireGondelPluginEvent","eventName","initialValue","callback","callbackResult","isSyncron","processedResult","Error","addGondelPluginEventListener","eventListenerCallback","previousEventHandler","modifiedResult","_","firstNext","triggerPublicEvent","gondelComponent","target","eventData","canBubble","event","document","createEvent","eventTarget","getFirstDomNode","_ctx","_namespace","charAt","toUpperCase","slice","initEvent","component","name","_componentName","namespace","dispatchEvent","noop","Deferred","_this","this","promise","Promise","resolve","startComponentsFromRegistry","gondelComponentRegistry","domContext","gondelDomNodeList","Array","prototype","call","querySelectorAll","hasAttribute","push","pristineGondelDomNodes","filter","gondelDomNode","hasOwnProperty","getGondelAttribute","bootingDeferred","forEach","domNode","bootingFlag","registry","componentNameHelper","gondelComponents","map","gondelComponentRegisty","componentName","getAttribute","GondelComponent","getComponent","undefined","componentInstance","__identification","stop","internalStopMethod","_stopped","bind","constructComponent","newComponentNames","Object","keys","_activeComponents","setActiveState","gondelComponentStartPromise","all","startConstructedComponent","then","sync","start","length","reject","GondelComponentRegistry","_components","registerComponent","unregisterComponent","isActive","componentRegistries","__gondelRegistries","identifiedComponent","addition","id","Symbol","for","nodeType","getComponentByDomNode","firstNode","nodeName","findComponents","documentElement","components","attribute","nodes","_identifier","identification","getComponentName","i","node","gondelComponentInstance","eventNameMapping","focus","blur","domEventRegistry","__gondelDomEvents","matches","Element","matchesSelector","mozMatchesSelector","msMatchesSelector","oMatchesSelector","webkitMatchesSelector","handleEvent","attributeName","eventHandlerRegistry","handlers","results","cancelBubble","handlerObject","handlerOptions","ctx","j","handlerResult","handlerName","executeHandlers","parents","startElement","element","parentElement","getParentElements","selectorsOfFoundComponents","parent","index","handlerQueue","_a","selectorName","sort","handlerA","handlerB","getHandlers","getEventRegistry","addRootEventListener","domEventName","gondelComponentName","handlerOption","namespacedDomEventRegistry","eventRegistry","isNativeEvent","addEventListener","selectorKey","selector","assign","areEventsHookedIntoCore","hookEventDecoratorInCore","componentEventOptions","__events","eventOptions","removeRootEventListernerForComponent","GondelBaseComponent","rootComponent","unshift","constructor","handler","substr"],"mappings":"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"}